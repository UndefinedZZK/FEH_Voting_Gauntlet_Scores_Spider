#coding:utf-8
import sys
reload(sys)
sys.setdefaultencoding("utf-8")
from FEH_Voting_Gauntlet_Scores_Spider.spiders import feh_voting_gauntlet_scores_spider
from FEH_Voting_Gauntlet_Scores_Spider import settings as my_settings
from scrapy.crawler import CrawlerRunner
from scrapy.settings import Settings
from twisted.internet import reactor
from twisted.internet import task
from wxpy import *
import json
import sched, time, logging, requests

Chinese_name_dict = {
	'Takumi': '拓海',
	'Hinoka': '日乃香',
	'Karel': '卡烈尔',
	'Soren': '塞内利奥',
	'Shanna': '夏娜',
	'Amelia': '艾米莉亚',
	'Katarina': '卡特琳娜',
	'Ryoma': '龙马'
}
who_is_behind = ''

crawler_settings = Settings()
crawler_settings.setmodule(my_settings)
spider_timeout = 60

wechat_bot = Bot(console_qr=True)
# wechat_friend = wechat_bot.friends().search(u'直援会特约FEH投票战小助手')[0]
wechat_friend = wechat_bot.friends().search('Zac ZHOU')[0]
# feh_group = wechat_bot.groups().search(u'测试')[0]
feh_group = wechat_bot.groups().search(u'维罗妮卡与庆祝十九大胜利闭幕')[0]

# WeChat Group message settings
@wechat_bot.register([wechat_friend, feh_group], TEXT)
def auto_reply(msg):
    if isinstance(msg.chat, Group) and not msg.is_at:
        return
    else:
        if "Who is behind" in msg.text or "who is behind" in msg.text or "谁落后" in msg.text or "谁劣势" in msg.text:
            print who_is_behind
            return who_is_behind
        elif "直援会" in msg.text:
            return "小直姐姐最棒啦！快加入直援会和我们一起感受小直姐姐学霸光辉的洗礼吧~"
        elif "iPhone" in msg.text or "ipx" in msg.text or "手机" in msg.text:
            print last_available_sentence
            return last_available_sentence
        else:
            return "不能理解你说的话嘤嘤嘤 请你找开发者@Zac ZHOU 哦对了现在版本还不支持艾特人"

# Read scores json file which is generated by spider, and return a dictionary
def read_scores_json():
    score_file = open('feh_voting_gauntlet_scores.json', 'r')
    scores = json.loads(score_file.read())
    score_file.close()
    return scores

# Compare the current scores and original scores, if there are changes then append to a list
def score_changes(scores_new):
    score_change_list = []
    for key, value in scores_new.iteritems():
        print key, value['is_behind'], value['score']
        if (key not in scores_original or scores_original[key]['score'] != value['score']) and value['is_behind'] == True:
            score_change_list.append(Chinese_name_dict[key])
        scores_original[key] = value
    return score_change_list

def update_who_is_behind(score_change_list):
    if score_change_list:
        global who_is_behind
        initial_update = who_is_behind == ''
        who_is_behind = ' '.join(score_change_list) + ' 劣势啦！'
        if initial_update is not True:
            # wechat_friend.send(who_is_behind)
            feh_group.send(who_is_behind)

# Here is for check ipx
colorToPartNumber = {'white': 'MQAG2B/A', 'black': 'MQAF2B/A'}
yourAddress = 'WC1E 6BT'
last_available_sentence = ''

def getAddressForURL():
	return yourAddress.replace(' ', '%20')

def checkPickupInStoreList(storeList, color):
    global last_available_sentence
    last_available_sentence = ''
    for store in storeList:
        pickupSituationForStores = store['partsAvailability'][colorToPartNumber[color]]['storePickupQuote']
        last_available_sentence = ' '.join([last_available_sentence, '\n', time.strftime("%a, %d %b %Y %H:%M:%S", time.gmtime()), 'iPhone 256G with color', color, pickupSituationForStores])
        pickupSituationAbbreviation = store['partsAvailability'][colorToPartNumber[color]]['pickupSearchQuote']
        if (pickupSituationAbbreviation != 'Currently unavailable'):
            notifyMessage = str(' '.join(['Iphone X with color', color, pickupSituationForStores]))
            wechat_friend.send(notifyMessage)
    print last_available_sentence

def scheduleIpxCheck():
	requestURLforWhite = ''.join(['https://www.apple.com/uk/shop/retail/pickup-message?pl=true&parts.0=', colorToPartNumber['white'], '&location=', getAddressForURL()])
	requestURLforBlack = ''.join(['https://www.apple.com/uk/shop/retail/pickup-message?pl=true&parts.0=', colorToPartNumber['black'], '&location=', getAddressForURL()])
	storeListforWhite = requests.get(requestURLforWhite).json()['body']['stores']
	storeListforBlack = requests.get(requestURLforBlack).json()['body']['stores']
	checkPickupInStoreList(storeListforWhite, 'white')
	checkPickupInStoreList(storeListforBlack, 'black')
	print '==================================================================================================='

# Very messy spider, need to refactor in the future
def run_spider():
    scheduleIpxCheck()
    update_who_is_behind(score_changes(read_scores_json()))
    loop_call.stop()
    runner = CrawlerRunner(crawler_settings)
    process = runner.crawl(feh_voting_gauntlet_scores_spider.FehVotingGauntletScoresSpider)
    process.addBoth(lambda _: loop_call.start(spider_timeout, False))

# Main
print "FEH voting gaunliet score spider started!"

scores_original = {}
update_who_is_behind(score_changes(read_scores_json()))

loop_call = task.LoopingCall(run_spider)
loop_call.start(spider_timeout)

reactor.run()
